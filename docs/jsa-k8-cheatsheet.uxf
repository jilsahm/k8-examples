<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.3.0">
  <help_text>// Uncomment the following line to change the fontsize and font:
// fontsize=14
fontfamily=Monospaced //possible: SansSerif,Serif,Monospaced


//////////////////////////////////////////////////////////////////////////////////////////////
// Welcome to UMLet!
//
// Double-click on elements to add them to the diagram, or to copy them
// Edit elements by modifying the text in this panel
// Hold Ctrl to select multiple elements
// Use Ctrl+mouse to select via lasso
//
// Use +/- or Ctrl+mouse wheel to zoom
// Drag a whole relation at its central square icon
//
// Press Ctrl+C to copy the whole diagram to the system clipboard (then just paste it to, eg, Word)
// Edit the files in the "palettes" directory to create your own element palettes
//
// Select "Custom Elements &gt; New..." to create new element types
//////////////////////////////////////////////////////////////////////////////////////////////


// This text will be stored with each diagram;  use it for notes.</help_text>
  <zoom_level>5</zoom_level>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>800</x>
      <y>535</y>
      <w>205</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>
Deployment

-
A Deployment is one of the Kubernetes objects 
that is used to manage Pods via ReplicaSets in 
a declarative way. It provides updates control 
as well as rollback functionalities. This means 
you can update or downgrade an application to 
the desired version without experiencing a user 
blackout as well as roll back to the previous 
version in case the new version is unstable or 
filled with bugs.
-
apiVersion: apps/v1
kind: Pod
metadata:
  name: &lt;deployname&gt;
  labels:
    &lt;key&gt;: &lt;value&gt;
spec:
  replicas: &lt;n&gt;
  selector:
    matchLabels: # the labels from the Pods
      &lt;key&gt;: &lt;value&gt;
  template:
    # include metadata and spec
    # from Pod definition here
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>260</x>
      <y>575</y>
      <w>210</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>
Pod

-
The smalles object for running containers in K8.
There is 1 to n containers running in a Pod.
Most of the time one Pod contains one container.
-
apiVersion: v1
kind: Pod
metadata:
  name: &lt;podname&gt;
  labels:
    &lt;key&gt;: &lt;value&gt;
spec:
  serviceAccount: &lt;serviceaccountname&gt;
  containers:
  - name: &lt;containername&gt;
    image: &lt;image&gt;
    ports:
    - containerPort: &lt;port&gt;
    envFrom:
    - configMapRef:
        name: &lt;configmapname&gt;
    - secretRef:
        name: &lt;secretname&gt;
    resources:
      requests: # minimum resources 
        memory: "&lt;ram&gt;"
        cpu: "&lt;cpu&gt;"
      limits: # maximum resources
        memory: "&lt;ram&gt;"
        cpu: "&lt;cpu&gt;"</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>535</x>
      <y>550</y>
      <w>205</w>
      <h>205</h>
    </coordinates>
    <panel_attributes>
ReplicaSet

-
A ReplicaSet is a process that runs multiple 
instances of a Pod and keeps the specified 
number of Pods constant. Its purpose is to 
maintain the specified number of Pod instances 
running in a cluster at any given time to 
prevent users from losing access to their 
application when a Pod fails or is inaccessible.
-
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: &lt;replicasetname&gt;
spec:
  replicas: &lt;n&gt;
  selector:
    matchesLabels: # the labels from the Pods
      &lt;key&gt;: &lt;value&gt;
    template:
      # include metadata and spec 
      # from Pod definition here</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>735</x>
      <y>645</y>
      <w>75</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
creates</panel_attributes>
    <additional_attributes>10.0;20.0;130.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>465</x>
      <y>640</y>
      <w>80</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
manages</panel_attributes>
    <additional_attributes>10.0;20.0;140.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>535</x>
      <y>830</y>
      <w>205</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>
Service

-

-
FQDN Structure:
  &lt;servicename&gt;.&lt;namespace&gt;.svc.cluster.local
Pods in the sample namespace only need to use
the &lt;servicename&gt; in order to connect to it.
-</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>380</x>
      <y>350</y>
      <w>205</w>
      <h>115</h>
    </coordinates>
    <panel_attributes>
Secret

-

-
In case a secret is mounted as a volumne each
value will be written in a file named as key
under the mounted folder.
-
apiVerions: v1
kind: Secret
metadata:
  name: &lt;secretname&gt;
data:
  &lt;key1&gt;: &lt;base64-value1&gt;
  &lt;key2&gt;: &lt;base64-value2&gt;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>710</x>
      <y>350</y>
      <w>205</w>
      <h>115</h>
    </coordinates>
    <panel_attributes>
ServiceAccount

-
Used by machines in order to get access to
specific cluster operations.
-
apiVersion: v1
kind: ServiceAccount
metadata:
  name: &lt;serviceaccountname&gt;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>150</x>
      <y>365</y>
      <w>205</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>
ConfigMap

-
Outsourcing and sharing for plaintest key=value 
properties used by other objects.
-
apiVersion: v1
kind: ConfigMap
metadata:
  name: &lt;configmapname&gt;
data:
  &lt;key1&gt;: &lt;value1&gt;
  &lt;key2&gt;: &lt;value2&gt;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1055</x>
      <y>475</y>
      <w>205</w>
      <h>105</h>
    </coordinates>
    <panel_attributes>
Namespace

-
Kubernetes supports multiple virtual clusters 
backed by the same physical cluster. These 
virtual clusters are called namespaces.
Namespaces are intended for use in environments 
with many users spread across multiple teams, 
or projects.
-
apiVersion: v1
kind: Namespace
metadata:
  name: &lt;namespacename&gt;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>435</y>
      <w>110</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=-
can be referenced by 
any other object in its
metadata block
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1055</x>
      <y>635</y>
      <w>205</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>
ResourceQuota

-
By default, containers run with unbounded 
compute resources on a Kubernetes cluster. 
With resource quotas, cluster administrators 
can restrict resource consumption and creation 
on a namespace basis. Within a namespace, a 
Pod or Container can consume as much CPU and 
memory as defined by the namespace's resource 
quota.
-
apiVersion: v1
kind: ResourceQuota
metadata:
  name: &lt;quotaname&gt;
  namespace: &lt;namespace to be limited&gt;
spec:
  hard:
    pods: &lt;n&gt;
    requests:
      cpu: "&lt;cpu&gt;"
      memory "&lt;ram&gt;"
    limits:
      cpu: "&lt;cpu&gt;"
      memory "&lt;ram&gt;" 
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>575</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
limits</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>245</x>
      <y>460</y>
      <w>135</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>lt=-</panel_attributes>
    <additional_attributes>250.0;110.0;10.0;110.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>365</x>
      <y>460</y>
      <w>135</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>lt=-</panel_attributes>
    <additional_attributes>250.0;10.0;250.0;110.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>360</x>
      <y>510</y>
      <w>60</w>
      <h>75</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
injected in</panel_attributes>
    <additional_attributes>10.0;130.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>580</x>
      <y>415</y>
      <w>140</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
creates to 
store token</panel_attributes>
    <additional_attributes>10.0;20.0;260.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>590</x>
      <y>105</y>
      <w>205</w>
      <h>135</h>
    </coordinates>
    <panel_attributes>
RoleBinding

-

-
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: &lt;bindingname&gt;
  namespace: &lt;namespace&gt;
subjects:
- kind: ServiceAccount
  name: &lt;serviceaccountname&gt;
  namespace: default
roleRef:
  kind: &lt;Role|ClusterRole&gt;
  name: &lt;rolename|clusterrolename&gt;
  apiGroup: rbac.authorization.k8s.io</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>825</x>
      <y>105</y>
      <w>205</w>
      <h>135</h>
    </coordinates>
    <panel_attributes>
Role

-

-
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: &lt;rolename&gt;
  namespace: &lt;namespace&gt;
rules:
- apiGroups:
  - ''
  resources: # resouces the role has access to
  - pods
  verbs: # verbs the role has access to
  - get
  - watch
  - list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>805</x>
      <y>285</y>
      <w>130</w>
      <h>75</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
grant RBAC permissions to
(Role Based Access Control)</panel_attributes>
    <additional_attributes>10.0;130.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>805</x>
      <y>235</y>
      <w>135</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>lt=-</panel_attributes>
    <additional_attributes>250.0;10.0;250.0;110.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>685</x>
      <y>235</y>
      <w>135</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>lt=-</panel_attributes>
    <additional_attributes>250.0;110.0;10.0;110.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1285</x>
      <y>635</y>
      <w>205</w>
      <h>145</h>
    </coordinates>
    <panel_attributes>
LimitRange

-
A LimitRange is a policy to constrain resource 
allocations (to Pods or Containers) in a 
namespace.
-
apiVersion: v1
kind: LimitRange
metadata:
  name: &lt;limitrangename&gt;
spec:
  limits:
  - default:
      &lt;memory|cpu&gt;: "&lt;value&gt;"
    defaultRequest:
      &lt;memory|cpu&gt;: "&lt;value&gt;"
    type: Container
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1185</x>
      <y>575</y>
      <w>215</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
limits</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0;410.0;90.0;410.0;120.0</additional_attributes>
  </element>
</diagram>
